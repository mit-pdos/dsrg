<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Thialfi</title>
  <meta name="description" content="Why did we read this paper?">

  <base href="/" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://dsrg.pdos.csail.mit.edu/2013/07/03/thialfi.html">
  <link rel="alternate" type="application/rss+xml" title="Distributed Systems Reading Group" href="http://dsrg.pdos.csail.mit.edu/feed.xml" />
  <link href='/stylesheets/all-b5d41f4fa671ec94597e984da68527b0.css' media='all' rel='stylesheet' type='text/css'>
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Distributed Systems Reading Group</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/papers/">Papers</a>
          
        
          
          <a class="page-link" href="/schedule/">Schedule</a>
          
        
      </div>
    </nav>

  </div>

</header>

    <div class="page-content">
      <div class="wrapper">
        <aside class="recent-posts">
  <h2>Recent posts</h2>
  <ul>
      
        <li>
          <span class="post-meta">Jan 10, 2014</span>
          <h2>
            <a class="post-link" href="/2014/01/10/epaxos.html">EPaxos</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Dec 16, 2013</span>
          <h2>
            <a class="post-link" href="/2013/12/16/sinfonia.html">Sinfonia</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Sep 30, 2013</span>
          <h2>
            <a class="post-link" href="/2013/09/30/spark-streaming.html">Discretized Streams</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Sep 30, 2013</span>
          <h2>
            <a class="post-link" href="/2013/09/30/spanstore.html">SPANStore</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Aug 8, 2013</span>
          <h2>
            <a class="post-link" href="/2013/08/08/chain-replication.html">Chain Replication</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 25, 2013</span>
          <h2>
            <a class="post-link" href="/2013/07/25/mdcc.html">MDCC</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 18, 2013</span>
          <h2>
            <a class="post-link" href="/2013/07/18/coralcdn.html">CoralCDN</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 11, 2013</span>
          <h2>
            <a class="post-link" href="/2013/07/11/zookeeper.html">Zookeeper</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 3, 2013</span>
          <h2>
            <a class="post-link" href="/2013/07/03/thialfi.html">Thialfi</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jun 20, 2013</span>
          <h2>
            <a class="post-link" href="/2013/06/20/vr-revisited.html">VR Revisited</a>
          </h2>
        </li>
      
  </ul>
</aside>
<div class="post">

  <header class="post-header">
    <h1 class="post-title">Thialfi</h1>
    <p class="post-meta">Jul 3, 2013</p>
  </header>

  <article class="post-content">
    <h2 id="why-did-we-read-this-paper">Why did we read this paper?</h2>

<p>Several of the papers we’ve read recently have focused on sophisticated,
generic fault tolerance abstractions based on complex protocols.
<a href="http://www.cs.columbia.edu/~lierranli/coms6998-11Fall2012/papers/thia_sosp2011.pdf">Thialfi</a>
offers a contrast: its approach to fault tolerance is intentionally
simple, while at the same time being resilient to arbitrary (halting)
failure, including entire data centers.  Thialfi’s approach to fault
tolerance permeates the design of its abstraction, unlike Raft and VR,
which provide general-purpose state machine replication.</p>

<p>Thialfi is also a real, massively deployed system, but is simple enough
to explain in more depth within the constraints of a conference paper
than most production systems.</p>

<h2 id="what-is-thialfi">What is Thialfi?</h2>

<p>The paper calls Thialfi a “notification service”, but really it’s an
object update signaling service.  When an application server updates an
object, it notifies Thialfi, and Thialfi notifies end-user clients on
the Internet that have registered for the object.  Critically, these
“notifications” contain no information about how the object
changed—the client has to query the application server to get its
updated state—which means Thialfi is free to combine notifications and
to generate spurious notifications, as long as clients interested in an
object eventually get at least one notification that the object has
changed if the client’s last seen version is not the object’s current
version.</p>

<p>Under normal operation, Thialfi delivers timely update notifications to
connected clients, without any polling (clients must send periodic
heartbeats to maintain the connection, but these are infrequent, small,
and efficient to process).  When a client goes offline and later
returns, Thialfi remembers its previous object registrations and sends
only notifications for objects that changed while the client was
offline.  Similarly, the client only needs to resend its registrations
if they have changed since it was last online or if it was offline for
over two weeks (after which Thialfi garbage collects its state).</p>

<h2 id="designing-for-fault-tolerance">Designing for fault tolerance</h2>

<p>There are a few core ideas in Thialfi’s design that help it achieve
fault tolerance.  These are not necessarily unique to Thialfi, but they
work well in concert.</p>

<p>Thialfi’s abstraction is carefully chosen to enable simple fault
tolerance.  Thialfi is <em>always</em> allowed to respond to clients with “I
don’t know”; in the worst case, the client will fall back to polling the
application server.  This is a key choice because it means Thialfi is
free to drop any and all state, as long as it never incorrectly claims
to know the version of an object.  In fact, the initial design presented
by the paper (4.1) is entirely in-memory, yet can survive data center
failures.  At first, this may seem like an undesirable abstraction to
build a client application atop, but, in fact, clients already have to
deal with this when they first run.</p>

<p>Since the only thing Thialfi can tell a client is “object X might have
changed”, it’s free to coalesce, repeat, and generate spurious
notifications.  The only thing it’s not allowed to do is drop a
notification entirely.  Since, faced with arbitrary faults, there’s no
way to know whether or not a notification was dropped, Thialfi
conservatively generates spurious notifications whenever a failure
<em>might</em> have caused a notification to be dropped.</p>

<p>Responsibility for hard state is colocated with the nodes that care
about that hard state.  A client is responsible for its object
registrations, because if the client dies, its registrations don’t
matter.  Likewise, an application server is responsible for application
data, because it has to persist that anyway (and if it dies, there’s
nothing to send notifications about).</p>

<p>Regular paths and error handling paths are the same wherever possible.
This means they don’t have to distinguish errors from regular operation
and that the code is more likely to be correct (error handling code is
notoriously buggy largely because it doesn’t get exercised).  For
example, initial registration, modifications to registrations, handling
server loss of registration state, and re-registering after migration
are all handled in the same way: the client and server exchange digests
of what they think the registration state is in every heartbeat; if
these are out of sync, the client simply resends its entire set of
registrations.  This extends to the user of the client API as well: as
mentioned above, client cold-start and the loss of version state in
Thialfi are handled identically at an API level.</p>

<p>Ultimately, Thialfi makes recovering from failure the responsibility of
application servers and clients, keeping itself off the critical path
for anything.  This seems simple, but achieving this without burdening
application servers and clients requires careful and conscious design.</p>

<h2 id="discussion">Discussion</h2>

<p>We felt there was one dark corner of Thialfi’s design that makes it
difficult to completely understand its fault tolerance properties.
Application servers post version changes to Thialfi via Google’s
reliable pub-sub system, about which the paper is devoid of details.
It’s difficult to tell how the pub-sub system could fail and how this
would affect Thialfi.  Furthermore, if Thialfi bootstraps off a reliable
pub-sub system, what would have happened if Google had simply exposed a
client API to subscribe to the pub-sub system?  Our best guess is that
it wouldn’t have scaled to millions of clients like Thialfi does, but we
can only guess.</p>

<p>Thialfi’s approach of signaling rather than notification reprises the
long debate between “level-triggered” and “edge-triggered” interfaces in
OS and hardware design.  Level-triggered interfaces like <code>poll()</code> and
PCI interrupts have very similar properties to Thialfi’s API (e.g., like
a Thialfi notification, <code>poll()</code> only tells the caller that data is
available on an FD, not what the data is, or how many times the FD was
written to).  On the other hand, edge-triggered interfaces more closely
resemble the reliable pub-sub interface that Thialfi explicitly
rejected.  Historically, level-triggered interfaces have generally
scaled better, and we found it interesting to see this revisited and
reinforced from a very different perspective.</p>

  </article>

</div>

      </div>
    </div>

    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-968607-14']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>

</html>
