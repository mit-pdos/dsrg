<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>VR Revisited</title>
  <meta name="description" content="Why are we reading Viewstamped Replication Revisited?">

  <base href="/dsrg/" />
  <link rel="stylesheet" href="/dsrg/css/main.css">
  <link rel="canonical" href="http://mit-pdos.github.io/dsrg/2013/06/20/vr-revisited.html">
  <link rel="alternate" type="application/rss+xml" title="Distributed Systems Reading Group" href="http://mit-pdos.github.io/dsrg/feed.xml" />
  <link href='/dsrg/stylesheets/all-b5d41f4fa671ec94597e984da68527b0.css' media='all' rel='stylesheet' type='text/css'>
</head>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/dsrg/">Distributed Systems Reading Group</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/dsrg/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/dsrg/papers/">Papers</a>
          
        
          
          <a class="page-link" href="/dsrg/schedule/">Schedule</a>
          
        
      </div>
    </nav>

  </div>

</header>

    <div class="page-content">
      <div class="wrapper">
        <aside class="recent-posts">
  <h2>Recent posts</h2>
  <ul>
      
        <li>
          <span class="post-meta">Jan 10, 2014</span>
          <h2>
            <a class="post-link" href="/dsrg/2014/01/10/epaxos.html">EPaxos</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Dec 16, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/12/16/sinfonia.html">Sinfonia</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Sep 30, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/09/30/spark-streaming.html">Discretized Streams</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Sep 30, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/09/30/spanstore.html">SPANStore</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Aug 8, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/08/08/chain-replication.html">Chain Replication</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 25, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/07/25/mdcc.html">MDCC</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 18, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/07/18/coralcdn.html">CoralCDN</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 11, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/07/11/zookeeper.html">Zookeeper</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jul 3, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/07/03/thialfi.html">Thialfi</a>
          </h2>
        </li>
      
        <li>
          <span class="post-meta">Jun 20, 2013</span>
          <h2>
            <a class="post-link" href="/dsrg/2013/06/20/vr-revisited.html">VR Revisited</a>
          </h2>
        </li>
      
  </ul>
</aside>
<div class="post">

  <header class="post-header">
    <h1 class="post-title">VR Revisited</h1>
    <p class="post-meta">Jun 20, 2013</p>
  </header>

  <article class="post-content">
    <h2 id="why-are-we-reading-viewstamped-replication-revisited">Why are we reading Viewstamped Replication Revisited?</h2>

<p><a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf">Viewstamped Replication</a>
 is a mechanism for providing replication through a
Primary / Backup scheme. This paper provides a distilled view of this
technique along with several optimizations that can be applied. In particular,
this paper focuses solely on the Viewstamped Replication protocol
without looking at any specific implementation or uses.</p>

<p>While a general Primary / Backup replication scheme may seem easy to
get right, considering how to handle view changes and the
many optimizations that others have come up with over the years, this
paper provides a go-to source for building such a system.</p>

<p>Previously we have looked at the Paxos protocol for 
consensus as well as Spanner which is an externally consistent distributed storage system.
This paper sits in-between these two extremes in that it is a technique
used for replication, thus being more complete than one-time consensus, while
eliding the details of a full storage system like Spanner.</p>

<h2 id="what-is-viewstamped-replication">What is Viewstamped Replication?</h2>

<p>Viewstamped Replication (referred to as VR in the remainder of this post) is a
replication protocol that uses consensus to support a replicated state machine.
The replication state machine allows clients using this service to run operations
that either view or modify the state, upon which other services can be built
such as a distributed key-value store.</p>

<p>One goal of VR is to support <em>f</em> failures using 2<em>f</em> + 1 nodes, so it
should be used in a distributed system where failures may
occur. Beyond normal operation, the system handles two scenarios:
changing the primary between the current list of members in a <em>view
change</em> as well as changing the set of participating members in a
<em>reconfiguration</em>.  This paper assumes that state replicated on many
machiens can be used for durability, thus avoiding a potential latency
of writing to persistent storage.  Unfortunately if VR is run in one
datacenter all the machines may be on the same power source and thus
in the same failure domain, so this might not be practical without a UPS.</p>

<h2 id="architecture">Architecture</h2>

<p>Some number of clients will be interacting directly with a service such as a
key-value store. The clients use a VR library or proxy that will abstract away
the details of the replication so that client code will use the abstraction of
“read” and “write” like operations on client defined state. Clients will use a
monotonically increasing request number which will allow the system to detect
duplicate requests.</p>

<p>Some number of servers 2<em>f</em> + 1 when trying to support
<em>f</em> failures) will run the VR code as well as the service code. The
VR code on the server will determine when to apply operations on the service
data and push these operations up to the service code. Note that these servers
can return after a failure (or network partition) and will only result in a
view change which would require getting the failed / partitioned node(s) up to
date.</p>

<p>Note that in VR as presented in this paper, the operations are performed on
several different replicas (instead of shipping the data around after the
operation has been performed). As a result, the operations  must be
deterministic.  It is mentioned in the
paper that particular techniques can be used to ensure this property.</p>

<p>As this is a Primary / Backup based system, the ordering is decided by the
primary, however <em>f</em> + 1 replicas must know about a request before
executing it to ensure durability despite failures and that ordering is guaranteed.</p>

<h2 id="system-operation">System Operation</h2>

<p>The system is in one of three states. These states are normal
operation, view changes when the system needs a new primary, and reconfiguration
when membership is changing. The primary node is deterministically chosen based
on the configuration (list of servers) and the view numbers. As a result
this system does not need to rely on voting or consensus (e.g. longest
log) to determine the next leader to take over.</p>

<h3 id="normal-operation">Normal Operation</h3>

<p>Replicas use a view number to determine if they are in the correct state. If
the sender is behind the receiver will drop the message, on the other hand if a
sender is ahead the receiver must update itself first and then process the
message.</p>

<p>A client sends a request to perform an operation at the server. The server then
sends <code>Prepare</code> messages to each of the backups and waits for 
<em>f</em> <code>PrepareOk</code> responses. Once it has received these responses it can
assume that the message will persist and it applies the operation by making an
upcall to the service code and finally replies to the client. A backup will
perform the same operation but does not reply to the client.</p>

<h3 id="view-changes">View Changes</h3>

<p>View changes occcur when the system needs to elect a new leader. A key correctness
requirement for the protocol is that every operation executed by an up-call to
the service code must make it into the new view in the same order as the original
execution. To achieve this requirement, <em>f</em> + 1 logs are obtained and merged
using the view number to break conflicts in op number ordering.</p>

<p>Protocol:</p>

<ul>
  <li>Replica sends <code>StartViewChange</code> to all other replicas</li>
  <li>Receives f responses, sends <code>DoViewChange</code> to new primary</li>
  <li>New primary waits for <em>f</em> + 1 <code>DoViewChange</code> messages before assuming new view</li>
</ul>

<p>Note that sending a suffix of the log (e.g. 1-2 entries) in the
<code>DoViewChange</code> message will likely bring the new server up to date
without requiring any additional state transfer from the replicas.</p>

<h3 id="recovery">Recovery</h3>

<p>Server recovery has the correctness requirement that a replicamust be as up to
date as it was when it crashed, otherwise it may forget about ops that it
prepared. This is achieved by receiving state from other replicas using the
following recovery protocol (note that nodes do not participate in request
processing or view changes during the recovery phase):</p>

<ul>
  <li>Recovering node send “Recovery” message to all</li>
  <li>All reply with “RecoveryResponse”, view number and nonce (and log, etc if primary)</li>
  <li>Replica waits for <em>f</em> + 1 responses (and primary), applies log and begins normal processing</li>
</ul>

<p>Note that in the theoretical solution, logs may be prohibitively big, however
optimizations exist to trim the log (e.g. snapshots).</p>

<p>Client recovery is simply achieved by starting any new request with the old
request number (obtained from replicas) + 2.</p>

<h3 id="reconfiguration">Reconfiguration</h3>

<p>Though reconfiguration is discussed later in the paper, it fits the flow here
in that it is essentially the last mode of operation. Beyond that several
optimizations are considered to speed up various parts of the system.</p>

<p>Reconfiguration is used to add/remove nodes to the system (thus changing the
<em>f</em> failures that the system can handle) or to upgrade or relocate
machines (for long running systems). A reconfiguration is instantiated by an
administrator of the system. In this paper, the term “epoch” refers to a configuration
number and the “transitioning” state refers to a node that is currently changing
configurations. The reconfiguration is started similarly to other operations by
sending the operation to the leader, however included in this operation is the
new configuration (list of participating machines). The primary will then 
send the <code>StartEpoch</code> message and wait for <em>f</em> responses.</p>

<p>Any new replicas will be brough up to date before the epoch change (by sending
them a list of operations or a snapshot + diff). Once a new replica is up to date
it will send an <code>EpochStarted</code> message to old replicas. Thus, once
an old replica (that is not in the new configuration) has received <em>f</em> + 1
<code>EpochStarted</code> messages, it is free to shut down. Note that one
particular optimization is to bring new machines up to date (e.g. warm-up)
before performing the reconfiguration to minimize the down time during
transition as nodes will not respond to messages for earlier epochs or while
transitioning.</p>

<p>The administrator can determine status of old replicas by sending out
<code>CheckEpoch</code> messages and then know when it is safe to shut down old
machine(s).</p>

<p>One issue for this system is rendesvous, however the solution provided in the
paper is to simply publish it somewhere out-of-band.</p>

<h4 id="efficient-recovery">Efficient Recovery</h4>

<p>One concern is achieving efficient recovery of failed server machines. As
presented previously, sending the missing log could result in the transfer of a
substantial amount of data. One way to solve this is to store application state
as a “checkpoint” that represents a log prefix, thus allowing the transfer of a
potentially much more compressed state + some log diff.</p>

<p>After a server creates a checkpoint, it can mark any modification as “dirty”
and provide those as the diff over the last created checkpoint. A perhaps
generic way of accomplishing this diff is to use merkle trees to efficiently
determine which pages are dirty to avoid sending the entire checkpoint.
Finally, if the state is too large to transfer then the paper suggests an
out-of-band mechanism (e.g. sneakernet).</p>

<p>Note that checkpoints allow garbage collection of the log, but the log may
still be required to bring back a recovering node, so it is beneficial to keep
some of it, else the system will suffer the cost of state transfer between
servers.</p>

<h3 id="state-transfer">State Transfer</h3>

<p>State transfer between two replicas can exist in essentially two cases. One
being that there are missing operations in the current view. To solve this the
replica will simply obtain said operations from another replica. The second and
more difficult situation is that there was a view change in which case the
replica will set it’s op-number to the latest commit-number and obtain updates
from another replica. If there is a gap in this replica’s log, it will need to
fast-forward using application state (such as a checkpoint).</p>

<h3 id="other-optimizations">Other Optimizations</h3>

<p>There are a handful of optimizations that others have come up with since the
original VR procool was presented. One example is using Witnesses that aren’t
performing the operations. This is a simple extension to the system by having
<em>f</em> replicas act as log keepers that are only used for view changes and
recovery.</p>

<p>Another optimization is to batch operations which simply implies that if the
system is busy then piggy-back several operations in a single message.</p>

<p>Finally, <em>fast reads</em> is a technique used in several replication systems.
This essentially allows the primary to respond to a read request without going
through the full protocol. These can be performed at the Primary, though the
use of leases and loosely synchronized clocks are required to maintain
consistency. Additionally, if the user of the system is ok with stale data,
then reads can be served at backups where a backup will reply to a client if it
has seens commits up to that request.</p>

  </article>

</div>

      </div>
    </div>

    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-968607-14']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>

</html>
